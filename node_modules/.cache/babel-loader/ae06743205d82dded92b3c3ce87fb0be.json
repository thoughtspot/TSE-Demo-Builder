{"ast":null,"code":"import { optional } from \"./accessors.js\";\nimport { Node, computeHeight } from \"./hierarchy/index.js\";\nvar preroot = {\n  depth: -1\n},\n    ambiguous = {},\n    imputed = {};\n\nfunction defaultId(d) {\n  return d.id;\n}\n\nfunction defaultParentId(d) {\n  return d.parentId;\n}\n\nexport default function () {\n  var id = defaultId,\n      parentId = defaultParentId,\n      path;\n\n  function stratify(data) {\n    var nodes = Array.from(data),\n        currentId = id,\n        currentParentId = parentId,\n        n,\n        d,\n        i,\n        root,\n        parent,\n        node,\n        nodeId,\n        nodeKey,\n        nodeByKey = new Map();\n\n    if (path != null) {\n      const I = nodes.map((d, i) => normalize(path(d, i, data)));\n      const P = I.map(parentof);\n      const S = new Set(I).add(\"\");\n\n      for (const i of P) {\n        if (!S.has(i)) {\n          S.add(i);\n          I.push(i);\n          P.push(parentof(i));\n          nodes.push(imputed);\n        }\n      }\n\n      currentId = (_, i) => I[i];\n\n      currentParentId = (_, i) => P[i];\n    }\n\n    for (i = 0, n = nodes.length; i < n; ++i) {\n      d = nodes[i], node = nodes[i] = new Node(d);\n\n      if ((nodeId = currentId(d, i, data)) != null && (nodeId += \"\")) {\n        nodeKey = node.id = nodeId;\n        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);\n      }\n\n      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += \"\")) {\n        node.parent = nodeId;\n      }\n    }\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n\n      if (nodeId = node.parent) {\n        parent = nodeByKey.get(nodeId);\n        if (!parent) throw new Error(\"missing: \" + nodeId);\n        if (parent === ambiguous) throw new Error(\"ambiguous: \" + nodeId);\n        if (parent.children) parent.children.push(node);else parent.children = [node];\n        node.parent = parent;\n      } else {\n        if (root) throw new Error(\"multiple roots\");\n        root = node;\n      }\n    }\n\n    if (!root) throw new Error(\"no root\"); // When imputing internal nodes, only introduce roots if needed.\n    // Then replace the imputed marker data with null.\n\n    if (path != null) {\n      while (root.data === imputed && root.children.length === 1) {\n        root = root.children[0], --n;\n      }\n\n      for (let i = nodes.length - 1; i >= 0; --i) {\n        node = nodes[i];\n        if (node.data !== imputed) break;\n        node.data = null;\n      }\n    }\n\n    root.parent = preroot;\n    root.eachBefore(function (node) {\n      node.depth = node.parent.depth + 1;\n      --n;\n    }).eachBefore(computeHeight);\n    root.parent = null;\n    if (n > 0) throw new Error(\"cycle\");\n    return root;\n  }\n\n  stratify.id = function (x) {\n    return arguments.length ? (id = optional(x), stratify) : id;\n  };\n\n  stratify.parentId = function (x) {\n    return arguments.length ? (parentId = optional(x), stratify) : parentId;\n  };\n\n  stratify.path = function (x) {\n    return arguments.length ? (path = optional(x), stratify) : path;\n  };\n\n  return stratify;\n} // To normalize a path, we coerce to a string, strip the trailing slash if any\n// (as long as the trailing slash is not immediately preceded by another slash),\n// and add leading slash if missing.\n\nfunction normalize(path) {\n  path = `${path}`;\n  let i = path.length;\n  if (slash(path, i - 1) && !slash(path, i - 2)) path = path.slice(0, -1);\n  return path[0] === \"/\" ? path : `/${path}`;\n} // Walk backwards to find the first slash that is not the leading slash, e.g.:\n// \"/foo/bar\" ⇥ \"/foo\", \"/foo\" ⇥ \"/\", \"/\" ↦ \"\". (The root is special-cased\n// because the id of the root must be a truthy value.)\n\n\nfunction parentof(path) {\n  let i = path.length;\n  if (i < 2) return \"\";\n\n  while (--i > 1) if (slash(path, i)) break;\n\n  return path.slice(0, i);\n} // Slashes can be escaped; to determine whether a slash is a path delimiter, we\n// count the number of preceding backslashes escaping the forward slash: an odd\n// number indicates an escaped forward slash.\n\n\nfunction slash(path, i) {\n  if (path[i] === \"/\") {\n    let k = 0;\n\n    while (i > 0 && path[--i] === \"\\\\\") ++k;\n\n    if ((k & 1) === 0) return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/nathan.schroeder/Documents/dev/ts-integration-demo/node_modules/d3-hierarchy/src/stratify.js"],"names":["optional","Node","computeHeight","preroot","depth","ambiguous","imputed","defaultId","d","id","defaultParentId","parentId","path","stratify","data","nodes","Array","from","currentId","currentParentId","n","i","root","parent","node","nodeId","nodeKey","nodeByKey","Map","I","map","normalize","P","parentof","S","Set","add","has","push","_","length","set","get","Error","children","eachBefore","x","arguments","slash","slice","k"],"mappings":"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","sourcesContent":["import {optional} from \"./accessors.js\";\nimport {Node, computeHeight} from \"./hierarchy/index.js\";\n\nvar preroot = {depth: -1},\n    ambiguous = {},\n    imputed = {};\n\nfunction defaultId(d) {\n  return d.id;\n}\n\nfunction defaultParentId(d) {\n  return d.parentId;\n}\n\nexport default function() {\n  var id = defaultId,\n      parentId = defaultParentId,\n      path;\n\n  function stratify(data) {\n    var nodes = Array.from(data),\n        currentId = id,\n        currentParentId = parentId,\n        n,\n        d,\n        i,\n        root,\n        parent,\n        node,\n        nodeId,\n        nodeKey,\n        nodeByKey = new Map;\n\n    if (path != null) {\n      const I = nodes.map((d, i) => normalize(path(d, i, data)));\n      const P = I.map(parentof);\n      const S = new Set(I).add(\"\");\n      for (const i of P) {\n        if (!S.has(i)) {\n          S.add(i);\n          I.push(i);\n          P.push(parentof(i));\n          nodes.push(imputed);\n        }\n      }\n      currentId = (_, i) => I[i];\n      currentParentId = (_, i) => P[i];\n    }\n\n    for (i = 0, n = nodes.length; i < n; ++i) {\n      d = nodes[i], node = nodes[i] = new Node(d);\n      if ((nodeId = currentId(d, i, data)) != null && (nodeId += \"\")) {\n        nodeKey = node.id = nodeId;\n        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);\n      }\n      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += \"\")) {\n        node.parent = nodeId;\n      }\n    }\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n      if (nodeId = node.parent) {\n        parent = nodeByKey.get(nodeId);\n        if (!parent) throw new Error(\"missing: \" + nodeId);\n        if (parent === ambiguous) throw new Error(\"ambiguous: \" + nodeId);\n        if (parent.children) parent.children.push(node);\n        else parent.children = [node];\n        node.parent = parent;\n      } else {\n        if (root) throw new Error(\"multiple roots\");\n        root = node;\n      }\n    }\n\n    if (!root) throw new Error(\"no root\");\n\n    // When imputing internal nodes, only introduce roots if needed.\n    // Then replace the imputed marker data with null.\n    if (path != null) {\n      while (root.data === imputed && root.children.length === 1) {\n        root = root.children[0], --n;\n      }\n      for (let i = nodes.length - 1; i >= 0; --i) {\n        node = nodes[i];\n        if (node.data !== imputed) break;\n        node.data = null;\n      }\n    }\n\n    root.parent = preroot;\n    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);\n    root.parent = null;\n    if (n > 0) throw new Error(\"cycle\");\n\n    return root;\n  }\n\n  stratify.id = function(x) {\n    return arguments.length ? (id = optional(x), stratify) : id;\n  };\n\n  stratify.parentId = function(x) {\n    return arguments.length ? (parentId = optional(x), stratify) : parentId;\n  };\n\n  stratify.path = function(x) {\n    return arguments.length ? (path = optional(x), stratify) : path;\n  };\n\n  return stratify;\n}\n\n// To normalize a path, we coerce to a string, strip the trailing slash if any\n// (as long as the trailing slash is not immediately preceded by another slash),\n// and add leading slash if missing.\nfunction normalize(path) {\n  path = `${path}`;\n  let i = path.length;\n  if (slash(path, i - 1) && !slash(path, i - 2)) path = path.slice(0, -1);\n  return path[0] === \"/\" ? path : `/${path}`;\n}\n\n// Walk backwards to find the first slash that is not the leading slash, e.g.:\n// \"/foo/bar\" ⇥ \"/foo\", \"/foo\" ⇥ \"/\", \"/\" ↦ \"\". (The root is special-cased\n// because the id of the root must be a truthy value.)\nfunction parentof(path) {\n  let i = path.length;\n  if (i < 2) return \"\";\n  while (--i > 1) if (slash(path, i)) break;\n  return path.slice(0, i);\n}\n\n// Slashes can be escaped; to determine whether a slash is a path delimiter, we\n// count the number of preceding backslashes escaping the forward slash: an odd\n// number indicates an escaped forward slash.\nfunction slash(path, i) {\n  if (path[i] === \"/\") {\n    let k = 0;\n    while (i > 0 && path[--i] === \"\\\\\") ++k;\n    if ((k & 1) === 0) return true;\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}